// Copyright 2015, University of Freiburg,
// Chair of Artificial Intelligence.
// Author: Tim Schulte <schultet@informatik.uni-freiburg.de>.
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/schultet/goa/pkg/comm"
	"github.com/schultet/goa/pkg/opt"
	"github.com/schultet/goa/pkg/search"
	"github.com/schultet/goa/pkg/task"
)

var (
	// DEBUG flag
	DEBUG = false
	// PORT is the default port for agent communication
	PORT = 3035
	// HOST is the default host for agent communication
	HOST = "127.0.0.1"
)

func main() {
	//defer profile.Start(profile.CPUProfile, profile.ProfilePath("."), profile.NoShutdownHook).Stop()
	runtime.GOMAXPROCS(runtime.NumCPU())
	Execute()
}

// Execute executes planner commands. Currently only the search-command is
// implemented.
func Execute() {
	opts := generalOptions()
	opts.ParseUnforgiving(os.Args)
	problems := opts.GetList("problem")
	agents, err := comm.NewConnList(opts.GetList("agent"))

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	if len(problems) > 1 { // run planner threaded
		RunAgentsThreaded(problems, agents, opts)
	} else {
		RunAgent(problems[0], agents, opts) // run planner as individual process
	}
}

// RunAgentsThreaded (1) initializes task, heuristic, engine, and strategy f.e.
// agent and (2) starts the search process in a go-routine f.e. agent
func RunAgentsThreaded(problems []string, agents comm.ConnList, opts *opt.OptionSet) {
	if len(agents) != len(problems) {
		log.Fatalf("ERR: #Problems != #Agents. Problems:%v\nAgents:%v\n", len(problems), len(agents))
	}
	inChans, outChans := createChannels(agents)
	engines := make([]*search.Engine, 0, len(agents))
	for _, agent := range agents {
		agentID := agent.AgentID
		log.Printf("@Agent%2d | Port: %d\n", agentID, agent.Port)

		t, err := task.NewTaskFromFile(problems[agentID])
		if err != nil {
			log.Fatalf("%v\n", err)
		}
		if t.AgentID != agentID {
			log.Fatalf("ERR: AgentID of Task and ConnList do not match. Task:%v\nConn:%+v\nProbs:%+v\n", t.AgentID, agents, problems)
		}
		server, dispatcher := comm.CreateChanComm(agentID, agents, inChans, outChans)
		engines = append(engines, search.NewEngine(t, server, dispatcher, agents, opts))
	}

	timeout := time.Second * time.Duration(opts.GetFloat64("timeout"))
	var wg sync.WaitGroup
	wg.Add(len(engines))
	for i := 0; i < len(engines); i++ {
		go func(i int) {
			defer wg.Done()
			engines[i].Search(timeout)
		}(i)
	}
	wg.Wait()
}

// RunAgent initializes task, heuristic, engine, and strategy, then starts the
// search process by calling engine.Search()
func RunAgent(problem string, agents comm.ConnList, opts *opt.OptionSet) {
	t, err := task.NewTaskFromFile(problem)
	if err != nil {
		log.Fatalf("%v\n", err)
	}
	server, dispatcher := comm.CreateTCPComm(t.AgentID, agents)
	engine := search.NewEngine(t, server, dispatcher, agents, opts)
	engine.Search(time.Second * time.Duration(opts.GetFloat64("timeout")))
}

// GetJSONFiles returns a list of all files in 'folder' with '.json' suffix
func GetJSONFiles(folder string) []os.FileInfo {
	var res []os.FileInfo
	files, _ := ioutil.ReadDir(folder)
	for _, f := range files {
		if strings.HasPrefix(f.Name(), ".") {
			continue
		}
		if strings.HasSuffix(strings.ToLower(f.Name()), ".json") {
			res = append(res, f)
		}
	}
	return res
}

func createChannels(agents comm.ConnList) (in, out map[int]map[int]chan comm.Message) {
	in = make(map[int]map[int]chan comm.Message)
	out = make(map[int]map[int]chan comm.Message)
	for _, agent := range agents {
		in[agent.AgentID] = make(map[int]chan comm.Message)
		out[agent.AgentID] = make(map[int]chan comm.Message)
	}
	for _, agent := range agents {
		for _, other := range agents.Except(agent.AgentID) {
			in[agent.AgentID][other.AgentID] = make(chan comm.Message, comm.MsgBufferSize)
			out[other.AgentID][agent.AgentID] = in[agent.AgentID][other.AgentID]
		}
	}
	return in, out
}

// generalOptions defines the planners opt options, that can be parsed later
func generalOptions() *opt.OptionSet {
	opts := opt.NewOptionSet()
	opts.Add(opt.NewOption(opt.String, "search", 's', "", "search options"))
	opts.Add(opt.NewOption(opt.List, "agent", 'a',
		"for each involved agent specify its id, host, and port",
		"\"<id> <host> <port>\""))
	opts.Add(opt.NewOption(opt.List, "problem", 'p',
		"problem file in json format as generated by translate script. "+
			"If multiple files are provided, agents are run in threads "+
			"using go-channels instead of tcp/ip communication.",
		"domain/problem.json"))
	opts.Add(opt.NewOption(opt.List, "heuristic", 'h', "", "heur options"))
	opts.Add(opt.NewOption(opt.String, "pruning", ' ', "none", "action pruning method. Values: [none|sss]"))
	opts.Add(opt.NewOption(opt.Bool, "macros", 'm', "",
		"use macro projections"))
	opts.Add(opt.NewOption(opt.Float64, "timeout", 'x', "1800.0",
		"time budget in seconds"))
	opts.Add(opt.NewOption(opt.Int32, "planlimit", 'q', 1, "number of plans to generate"))
	opts.Add(opt.NewOption(opt.String, "logfile", 'l', "", "write logs to file"))
	opts.Add(opt.NewOption(opt.Bool, "nature", 'n', "", "add nature agent -> continual planning"))
	return opts
}
